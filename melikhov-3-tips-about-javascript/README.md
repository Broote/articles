# Пишем производительный JavaScript. 3 совета.
Эта статья основана на советах Benedikt Meurer, встреченных мной в статьях, комментариях и лекциях. Почему эта информация интересна и важна? Бенедикт принимает непосредственное участие в разработке V8 и досконально знает, как именно интерпретатор и компилятор обрабатывают наш код.

---

## Помогите javascript понять, что на самом деле вы хотите сделать
Избегайте неопределённости. Например, если у вас есть значение `obj`, которое может быть `undefined` или объектом, рассмотрите возможность исключения неопределенности через явное условие:

```javascrip
if (obj !== undefined) {
  // …
}
```

Тогда компилятору не придётся делать множество лишних проверок, как в случае, если вы напишите:

```javascript
if (obj) {
  // …
}
```

Что должен сделать компилятор в этом случае? Проверить, что `obj` не является пустой строкой, `false`, `0` или `undefined`. Всё это порождает лишние проверки в байткоде.

![](https://cdn-images-1.medium.com/max/2000/1*0my1ZiCSFkinC6HB5eY4Fw.png)
*Первый вариант в среднем на 15% быстрее.*

Дополнительная польза — когда вы будете читать свой код через год (или это будет делать кто-то другой), вам гораздо проще будет понять, что на самом деле проверяет ваше условие.

## Осторожнее с && и ||
![](https://cdn-images-1.medium.com/max/1600/1*8CZN4PG7s565SftA60yWCw.png)
*[https://github.com/developit/preact/pull/610](https://github.com/developit/preact/pull/610)*

Это пример из реального коммита в репозитории preact. Изменение логического выражения на тернарный оператор было сделано для повышения производительности кода (автор сообщает об 1–5% ускорении). Но за счёт чего?
Мы помогли компилятору, указав, что значением `vlen` всегда будет `Number`. В первом случае, в негативном сценарии мы получим тип `Boolean` для `vlen`, что и приводит к деоптимизации, а так же добавляет ещё одну дорогостоящую проверку позже, чтобы убедиться, что `vlen` на самом деле является числом.

Дополнительно ускорить код можно воспользовавшись советом из первой части статьи:

```javascript
vlen = (vchildren !== undefined) ? vchildren.length : 0;
```

В целом, использование `&&` или `||` в небулевом контексте (особенно с числами) не слишком хорошее решение, из-за семантики `&&` и `||` в JavaScript.

Ещё один интересный пример неправильного использования `||`:

```javascript
function foo(a, b) {
  a = a || "value";
  b = b || 4;
  // …
}
```

В данном случае ошибочно отсекаются допустимые значения, такие как пустая строка `''` для `a` и `0` для `b`.

## Не доверяйте undefined
Выше мы использовали проверку 

```javascript
if (obj !== undefined) {
  // …
}
```

 Но всё ли с ней хорошо? Давайте проведём небольшой опыт

```javascript
const isDefined = (function() {
  const undefined = 1;
  return x => x !== undefined;
})();
console.log(isDefined(undefined));  // true
console.log(isDefined(1));          // false
```

На самом деле undefined не является ключевым словом в javascript. Это просто поле в глобальном объекте, и движок js вынужден это учитывать. К счастью, в V8 уже присутствует неплохая оптимизация и если в цепочке видимости отсутствуют eval или with, компилятор не будет производить поиск значения undefined в глобальном объекте. Но вот в Safari такая оптимизация отсутствует. 

Защититься от подмены undefined (и немного упростить жизнь компилятору) можно путём вызова оператора void который всегда возвращает настоящий undefined.

```javascript
if (obj !== void 0) {
  // …
}
```

Подробнее читайте в статье [Benedikt Meurer: Sometimes undefined is defined](https://medium.com/@bmeurer/sometimes-undefined-is-defined-7701e1c9eff8)


---
